
import { app, BrowserWindow, ipcMain, Notification, Tray, Menu, dialog, shell, nativeImage, screen } from 'electron'
import path from 'node:path'
import Store from 'electron-store'
import fs from 'node:fs'
import { spawn } from 'node:child_process'
import chokidar from 'chokidar'

const store = new Store({ name: 'settings', defaults: { vaults: [], paused: false } })
let tray = null, win = null, overlay = null
const watchers = new Map(), timers = new Map()
let quitting = false

function notifyOS(title, body) { new Notification({ title, body, silent: false }).show() }
function runGit(cwd, args) {
  return new Promise((resolve, reject) => {
    const p = spawn('git', args, { cwd }); let out='', err=''
    p.stdout.on('data', d=> out += d.toString()); p.stderr.on('data', d=> err += d.toString())
    p.on('close', c=> c===0 ? resolve({out,err}) : reject(new Error(err||out)))
  })
}
async function ensureRepo(v){
  const gitDir = path.join(v.path, '.git')
  if (!fs.existsSync(gitDir)) { await runGit(v.path, ['init']); if (v.branch) await runGit(v.path, ['checkout','-B',v.branch]) }
  if (v.repoUrl) { try { await runGit(v.path,['remote','set-url','origin',v.repoUrl]) } catch { await runGit(v.path,['remote','add','origin',v.repoUrl]) } }
}
async function countChanges(cwd){ const s = await runGit(cwd,['status','--porcelain']); return s.out.split('\n').filter(Boolean).length }
async function syncVault(v){
  if (store.get('paused')) return { skipped: true }
  const started = new Date()
  try{
    await ensureRepo(v)
    if (v.onlyIfChanges && await countChanges(v.path)===0) {
      const p = { type:'info', text:`${v.name}: no changes to commit.`, title:'ObsiSync', meta:'', alpha: v.overlayAlpha ?? 0.55, scale: v.overlayScale ?? 0.92 }
      if (v.notifyOverlay !== false) showOverlay(p)
      return {changed:0,skipped:true}
    }
    await runGit(v.path,['add','-A'])
    const changed = await countChanges(v.path); if (changed===0) return {changed:0,skipped:true}
    const msg = (v.commitTemplate || 'ObsiSync: {count} files â€” {date}').replace('{count}', String(changed)).replace('{date}', started.toLocaleString())
    await runGit(v.path,['commit','-m',msg])
    if (v.branch) { try { await runGit(v.path,['pull','--rebase','origin',v.branch]) } catch {} await runGit(v.path,['push','origin',v.branch]) }
    const payload = { type:'success', text:`${v.name} synced ${changed} files`, title:'ObsiSync', meta:new Date().toLocaleTimeString(), alpha: v.overlayAlpha ?? 0.55, scale: v.overlayScale ?? 0.92 }
    if (v.notifyOS) notifyOS('ObsiSync', `${v.name} synced ${changed} files`)
    if (v.notifyOverlay !== false) showOverlay(payload)
    return { changed }
  } catch(e){
    const err = e?.message || String(e)
    const payload = { type:'error', text:`${v.name} ${err.slice(0,120)}`, title:'ObsiSync', meta:'', alpha:  v.overlayAlpha ?? 0.55, scale:  v.overlayScale ?? 0.92 }
    showOverlay(payload)
    notifyOS('ObsiSync error', err.slice(0,120))
    return {error:err}
  }
}
function startWatcher(v){ if (watchers.has(v.id)) return; const w = chokidar.watch(v.path,{ignored:/(^|[/\\])\./,ignoreInitial:true}); w.on('all',(event,f)=>win?.webContents.send('vault:activity',{id:v.id,event,file:f})); watchers.set(v.id,w) }
function getIntervalSeconds(v){ const s = v.intervalSec ?? (v.intervalMin ? v.intervalMin*60 : 600); return Math.max(30, Number(s)||600) }
function scheduleVault(v){ if (timers.has(v.id)) clearInterval(timers.get(v.id)); const ms = getIntervalSeconds(v) * 1000; timers.set(v.id, setInterval(()=>syncVault(v), ms)) }
function reloadSchedulers(){ for (const [,t] of timers) clearInterval(t); timers.clear(); if (store.get('paused')) return; const vs = store.get('vaults'); vs.forEach(v=>{ if (v.path && fs.existsSync(v.path)) { startWatcher(v); scheduleVault(v) } }) }

function resolveIcon(){
  const candidates = ['logo.ico','icon.ico','app.ico']
  for (const name of candidates){
    const p = path.join(process.cwd(), 'build', name)
    try {
      const img = nativeImage.createFromPath(p)
      if (!img.isEmpty()) return p
    } catch {}
  }
  return null
}

function createOverlay(){
  if (overlay && !overlay.isDestroyed()) return overlay
  const bounds = screen.getPrimaryDisplay().workArea
  overlay = new BrowserWindow({
    width: 360, height: 200, x: bounds.x + bounds.width - 360 - 16, y: bounds.y + bounds.height - 200 - 16,
    frame: false, transparent: true, resizable: false, movable: false, focusable: false, skipTaskbar: true,
    alwaysOnTop: true, backgroundColor: '#00000000',
    webPreferences: { preload: path.join(process.cwd(),'electron','overlay_preload.cjs'), nodeIntegration: false, contextIsolation: true }
  })
  overlay.setIgnoreMouseEvents(true)
  const devUrl = process.env.VITE_DEV_SERVER
  if (devUrl) overlay.loadURL(devUrl + '/notify.html'); else overlay.loadFile(path.join(process.cwd(),'public','notify.html'))
  return overlay
}
function showOverlay(payload){ const o = createOverlay(); o.webContents.send('overlay:show', payload) }

async function createWindow(){
  const iconPath = resolveIcon()
  win = new BrowserWindow({
    width: 1160, height: 720, backgroundColor:'#0a1023', titleBarStyle:'hiddenInset',
    resizable: false, maximizable: false, fullscreenable: false, minimizable: true,
    icon: iconPath || undefined,
    webPreferences:{ preload:path.join(process.cwd(),'electron','preload.cjs'), nodeIntegration:false, contextIsolation:true }
  })
  const devUrl = process.env.VITE_DEV_SERVER; if (devUrl) await win.loadURL(devUrl); else await win.loadFile(path.join(process.cwd(),'dist','index.html'))
  win.on('close', (e)=>{ if (!quitting) { e.preventDefault(); win.hide() } })
}

function rebuildTray(){
  const iconPath = resolveIcon()
  let trayIcon
  if (iconPath){
    try { trayIcon = nativeImage.createFromPath(iconPath) } catch {}
  }
  if (!trayIcon || trayIcon.isEmpty()) trayIcon = nativeImage.createEmpty()

  if (!tray) tray = new Tray(trayIcon); else tray.setImage(trayIcon);
  const menu = Menu.buildFromTemplate([
    {label:'Open ObsiSync', click:()=>{ win?.show(); win?.focus() }},
    {type:'separator'},
    {label: store.get('paused') ? 'Resume syncing' : 'Pause syncing', click:()=>{ store.set('paused', !store.get('paused')); reloadSchedulers(); rebuildTray() }},
    {label:'Sync all now', click: async()=>{ const tasks = store.get('vaults').map(v=>syncVault(v)); await Promise.all(tasks) }},
    {type:'separator'},
    {label:'Quit', click:()=>{ quitting = true; app.quit() }}
  ])
  tray.setToolTip('ObsiSync'); tray.setContextMenu(menu)
  tray.on('click', ()=>{ win?.show(); win?.focus() })
  tray.on('right-click', ()=>{ win?.show(); win?.focus() })
}

app.whenReady().then(async()=>{
  await createWindow(); createOverlay(); rebuildTray(); reloadSchedulers()
})
app.on('window-all-closed', ()=>{})

ipcMain.handle('dialog:pickFolder', async()=>{ const r = await dialog.showOpenDialog({properties:['openDirectory']}); if (r.canceled) return null; return r.filePaths[0] })
ipcMain.handle('store:get',(_,k)=>Store.prototype.get.call(store,k))
ipcMain.handle('store:set',(_,k,v)=>{ Store.prototype.set.call(store,k,v); reloadSchedulers(); return true })
ipcMain.handle('vault:sync', async(_,id)=>{ const v = store.get('vaults').find(x=>x.id===id); if (v) return await syncVault(v); return null })
ipcMain.handle('vault:openPath',(_,id)=>{ const v = store.get('vaults').find(x=>x.id===id); if (v?.path) shell.openPath(v.path) })
ipcMain.handle('paused:toggle',()=>{ store.set('paused', !store.get('paused')); reloadSchedulers(); rebuildTray(); return store.get('paused') })
